#!/usr/bin/env ruby

require 'pp'
require 'fileutils'
require 'tempfile'


SCM2C = {'*'=>'_A_', '-'=>'_', '?'=>'_P'}
C2SCM = {'_'=>'-', '_p'=>'?', '_i'=>'!', '_a'=>'*', '_to_'=>'->'}

def scm2c( str )
  str.gsub(/\*|-|\?/){|s| SCM2C[s]}.gsub(/^_|_$/,'')
end

def c2scm( str )
  str.gsub(/_to_|_p$|_a$|_i$|_/){|s| C2SCM[s] }
end

$symbols = []

def define_symbols( args )
  args.map! do |sym|
    if sym.is_a?( Array )
      {:sym => sym[0], :id => sym[1] }
    else
      {:sym => sym, :id => 'SYM_'+scm2c(sym).upcase }
    end
  end
  $symbols = args

  args.map do |sym|
    "extern Symbol *#{sym[:id]};"
  end
end

def declare_symbols()
  $symbols.map do |sym|
    "Symbol * #{sym[:id]};"
  end
end

def register_symbols()
  $symbols.map do |sym|
    "#{sym[:id]} = intern(\"#{sym[:sym]}\");"
  end
end

def register_cfunc(src)
  cfuncs = []
  src.gsub( /static Value ([\w\d_]+)\(.+?\)\s*\/\*\s*(.+?)\s*\*\// ) do |m|
    id = $1
    arity, sym = *($2.split(' '))
    sym = c2scm( id[1..-1] ) if !sym
    cfuncs << {:id => id, :arity => arity, :sym => sym }
  end
  # pp cfuncs
  cfuncs.map do |f|
    "defun( \"#{f[:sym]}\", #{f[:arity]}, #{f[:id]} );"
  end
end

########################################################
# SRC-FILTER
########################################################

def parse( src )
  src.gsub( /([ \t]*)\/\*{{(.+?)\*\/(.*?)\/\*}}\*\//m ) do |mo|
    indent = $1
    code = $2
    raise if $3.match(/\/\*{{/)
    result = eval( code )
    result = indent+result.join("\n#{indent}")+"\n"+indent if Array === result
    "#{indent}/*{{#{code}*/\n"+
      # "// THIS CODE IS AUTO-GENERATED BY src-filter\n"+
      "#{result}"+
      "/*}}*/"
  end
end


ARGV.each do |file|
  puts "converting #{file}..."
  code = open(file, "r:utf-8"){|f| f.read}
  converted_code = parse( code )
  if code != converted_code
    backup = Dir.tmpdir+"/"+file+Time.now.to_i.to_s
    puts "updating #{file} (backup to #{backup}"
    FileUtils.cp file, backup
    open(file,'w') do |f|
      f.write converted_code
    end
  end
end
